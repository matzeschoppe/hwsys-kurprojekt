% deckblatt.tex, 2019/03/15 
\documentclass[a4paper,12pt]{article}  
%Inhaltsverzeichnis in Kapitel und Sektionen aufgeteilt  \chapter{title} > \section{title} > subsection{title} \subsubsection{title}
% Pakete und Paket-Configs
\usepackage{times} % Times Roman als Standardschrift
\usepackage[ngerman]{babel} % neue deutsche Rechtschreibung und Trennung
\usepackage{fancyhdr} % spezielle Kopfzeilen
\usepackage[latin1]{inputenc} % Umlaute äöü auch normal benutzen und nicht maskieren
\usepackage[babel, german=quotes]{csquotes}
\usepackage{subfigure} % Figures divided into subfigures.
\usepackage{ifthen} % ErmÃ¶glicht ifthenelse und whiledo
\usepackage{amsfonts} % Extra mathematical symbols
\usepackage[rflt]{floatflt} % verbessertes floatfig, als um figure's fliesende texte
\usepackage[T1]{fontenc} % ?? aber notwendig fÃ¼r korrekte PDF-Metadaten
%\usepackage{longtable} % Support for tables longer than a page.
%\usepackage{a4wide} % Increases width of printed area of an a4 page.
%\usepackage{alltt} % verbatim environment except that \ and braces have their usual meanings.
\usepackage{listings} % Typeset source code listings using LaTeX.
\usepackage{moreverb} % bessere verbatim-umgebungen
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{caption}
\usepackage{amsmath}
\usepackage{xcolor} % Farben Definierbar \definecolor{fhorange}{RGB}{255,153,0}
\usepackage[backend=biber, natbib=true, style=numeric,sorting=none]{biblatex} % Für das Erstellen eines Literaturverzeichnisses
\addbibresource{literatur.bib}  % für das erstellen des Literaturverzeichnisses empfielt sich die Software Mendeley, diese ermöglicht einfaches hinzufügen Büchern und das exportieren in eine .bib Datei 
\usepackage{acronym}
\usepackage[pdfpagelabels=true]{hyperref}
\usepackage{float}
\usepackage{array}
\usepackage{notoccite}
\usepackage{minted}

\pagestyle{headings} % Kopf- und Fusszeilen
\pagenumbering{Roman} % Nummerierung der Seiten
\newcommand{\maximagewidth}{15cm} % maximal mögliche Bildbreite

\setlength{\parindent}{0cm} % Einrückung am Abstzanfang
\setlength{\parskip}{5pt plus 2pt minus 1pt} % Abstand der Absätze zueinander
\frenchspacing % Kein Zusatzzwischenraum nach Satzzeichen

\setcounter{secnumdepth}{3} % Zählung bis paragraph 1.1.1
\setcounter{tocdepth}{3} % Inhaltsverzeichnis bis paragraph 1.1.1

%\makeglossary % Schreibe ein Glossar-File

\title{Titel der Arbeit}
\author{Name des Authors}
\date{\today}
\definecolor{fhorange}{RGB}{255,153,0}
\begin{document}
	
	\begin{titlepage}
		\thispagestyle{empty}
		\begin{center}
			\begin{minipage}{15cm}
				\begin{flushright}
					\includegraphics[width=4cm]{fhlogo.png} \hspace{1.5cm} \\
					\textbf{\large Hochschule \hspace{3.5cm} ~ \\ Augsburg } \large University of \hspace{1cm} ~ \\ Applied Sciences \hspace{0.2cm} ~
					\\~
				\end{flushright}
				
				\begin{flushleft}
					\textbf{\large \textcolor{fhorange}{Hardwaresysteme\\Kürprojekt}} \hspace{8.35cm} \textcolor{fhorange}{\large Fakultät für}
					\vspace{0.1cm}
					\\~  \hspace{10.75cm} \textcolor{fhorange}{\large Informatik} 
				\end{flushleft}
				
				%\vspace{1cm}
				\begin{flushleft}
					{ \large Studienrichtung \\ 
						%	\vspace{0.2cm}
						M.Sc. Informatik
					}
					\vspace{0.1cm}
				\end{flushleft}
				\begin{flushleft}
					{
						\textcolor{fhorange}{\large \textbf{Mathias Schoppe \\
								Entwicklung eines ICs - Der Schaltkreisentwurf}}
					}
					\vspace{0.2cm}
				\end{flushleft}
				\begin{flushleft}
					{ \large Betreuer: Prof. Dr.-Ing. Gundolf Kiefer \\ 
						\vspace{0.1cm}
						Abgabe der Arbeit am: 09.07.2023 			
					}
				\end{flushleft}
				\begin{flushleft}
					%In Kooperation mit Firma: \\ Hsa-Digit \\ Betreuer: Hans Mustermann \\ 
					%\vspace{0.5cm}
					%\includegraphics[width=3cm]{hsa_digit.png} \hspace{5cm} 
					\tiny{\textcolor{gray}{
							\hspace{11.3cm} Hochschule für angewandte \\
							\hspace{11.3cm} Wissenschaften Augsburg \\
							\hspace{11.3cm} University of Applied Sciences \\ ~ \\
							\hspace{11.3cm} An der Hochschule 1 \\
							\hspace{11.3cm} D-86161 Augsburg \\ ~ \\
							\hspace{11.3cm} Telefon +49 821 55 86-0 \\
							\hspace{11.3cm} Fax +49 821 55 86-3222 \\
							\hspace{11.3cm} www.hs-augsburg.de \\
							\hspace{11.3cm} info@hs-augsburg.de \\} ~ \\
						\hspace{11.3cm} Fakultät für Informatik \\
						\hspace{11.3cm} Telefon +49 821 5586-3450 \\
						\hspace{11.3cm} Fax ~~~ +49 821 5586-3499 \\ ~ \\
						\hspace{11.3cm} Verfasser der Ausarbeitung: \\
						\hspace{11.3cm} Mathias Schoppe \\
						\hspace{11.3cm} Matr. Nr.: 2165952 \\
						\hspace{11.3cm} M. Sc. Informatik \\
						\hspace{11.3cm} Teamkollegen: Sascha Binkert \\
						\hspace{11.3cm} und Timo Winklbauer \\
						
					}
				\end{flushleft}
			\end{minipage}
		\end{center}
	\end{titlepage}
	
	
	% Zusammenfassung
	\thispagestyle{empty}
	\tableofcontents  
	% Wenn das Inhaltsverzeichnis aktualisiert werden muss 2 mal kompilieren, erst dann wird die Aktualisierung angezeigt
	\newpage
	\pagenumbering{arabic}
	\section{Einleitung}
	\label{sec:einleitung}
	\subsection{Motivation}
	In dieser Ausarbeitung liegt der Fokus auf der Entwicklung eines eigenen \acp{IC} mithilfe des Tiny-Tapeout-Projekts\cite{TT}. Der Prozess des \ac{IC}-Designs ist äußerst komplex und erfordert spezialisierte Kenntnisse sowie teure Ausrüstung und Ressourcen. Das Tiny-Tapeout-Projekt hat es geschafft, ein besonderes Konzept zu entwickeln, dass selbst Anfängern ermöglicht, ihre eigenen \ac{IC}-Designs zu realisieren. Es bietet eine kostengünstige Möglichkeit, ein eigenen \ac{IC} fertigen zu lassen und eröffnet somit neue Möglichkeiten für kreative Ideen und individuelle Schaltungen.
	Das Ziel der Arbeit besteht darin, ein eigenes \ac{IC}-Design für ein Reaktionsspiel zu entwerfen und zu simulieren. Hierbei wird darauf geachtet, dass maximal 500 Logikgatter und ausschließlich die Ein- und Ausgänge des Tiny-Tapeout Evaluationsboards für die Umsetzung benötigt werden. Durch die Realisierung dieses Projekts sollen grundlegende Kenntnisse im IC-Design erlangt und praktische Erfahrungen in der Entwicklung von elektronischen Schaltungen gesammelt werden. 
	Dieses Projekt wird in drei seperaten Ausarbeitungen unterteilt. Der Prozess des IC-Designs, verschiedene Tools von Tiny-Tapeout und der Schaltkreisentwurf des Reaktionsspiels werden jeweils von Timo Winklbauer, Sascha Binkert und Mathias Schoppe abgedeckt.
	Dieser Teil der Ausarbeitung behandelt Aspekte, welche für das Vorhaben der konkreten Umsetzung zu beachten sind und bezieht sich dabei auf den Entwurf des Reaktionsspiels.
	
%	\subsection{Struktur der Arbeit}
%	Die Struktur, Kapitel und die jeweiligen Unterpunkte sind im Inhaltsverzeichnis
%	übersichtlich dargestellt. Dieser Abschnitt fasst kurz zusammen, was in den fünf
%	Hauptpunkten beschrieben wird:
%	\begin{itemize}
%		\item[\ref{sec:einleitung}]
%		\textbf{Einleitung}\\
%		Die Einleitung verschafft einen Überblick über das zu behandelnde Thema und stellt die Motivation für die Verfassung der Arbeit dar.
%		\item[\ref{sec:theorie}]
%		\textbf{Grundlagen}\\
%		Das Kapitel Grundlagen legt die verwendeten Theorien und Konzepte dar, welche für die Umsetzung des Projektes unabdingbar sind.
%		\item[\ref{sec:icdesign}]
%		\textbf{Schaltkreis Entwurf}\\
%		\item[\ref{sec:eval}]
%		\textbf{Bewertung}\\
%		\item[\ref{sec:summary}]
%		\textbf{Zusammenfassung und Zukunftsausblick}\\
%		
%		
%	\end{itemize}
	\pagebreak
	\section{Grundlagen}
	\label{sec:theorie}
	Das nachfolgende Kapitel befasst sich mit grundlegenden Themen, welche für die Umsetzung der Arbeit unabdingbar sind. Die Themenbereiche werden zusammengefasst und so erläutert, dass auch Lesende ohne Vorerfahrung im Bereich der Hardwareentwicklung alle Aspekte der Arbeit nachvollziehen können. Es wird ausschließlich auf Grundlagen, welche relevant für die konkrete Umsetzung des Projekts sind, eingegangen. 
	\subsection{Linear rückgekoppeltes Schieberegister}
	\label{sec:lfsr}
	Ein \acl{LFSR} (engl. linear feedback shift register (\acs{LFSR})) ist eine Schaltung, die aus einer Reihe von Flip-Flops (digitale Speicherelemente) besteht, die in einer Kette miteinander verbunden sind. Die Rückkopplung erfolgt, indem das Ausgangssignal eines Flip-Flops mit dem Eingang eines vorherigen Flip-Flops verbunden wird. Dadurch bildet sich ein geschlossener Rückkopplungs-Pfad.\cite{fox2008linear}\\
	Die Anzahl der Flip-Flops in einem Schieberegister bestimmt die Anzahl der Speicherplätze oder Zustände, die es halten kann. Ein 4-Bit-Schieberegister kann beispielsweise 16 verschiedene Zustände einnehmen, während ein 8-Bit-Schieberegister 256 verschiedene Zustände einnehmen kann. 
	
	\vspace{1em}
	\begin{minipage}{\linewidth}
		\centering
		\includegraphics[width=1\linewidth]{pics/lfsr.pdf}
		\captionof{figure}[lfsr]{Abbildung eines Fibonacci-LFSR, angelehnt an \cite{LFSRWiki}}
		\label{fig:lfsr}
	\end{minipage}
	\vspace{1em}
	
	In Abbildung \ref{fig:lfsr} ist ein 8-Bit Fibonacci-\acs{LFSR} dargestellt. 
	Dabei repräsentiert CLK den Takteingang und Y den Ausgang des \acs{LFSR}. Bei jedem Taktimpuls wird der gespeicherte Wert der Flip-Flops eine Stelle weiter geschoben. Bei jedem Taktimpuls wird das Rückkopplungs-Bit in das erste Flip-Flop des Schieberegisters eingespeist, alle anderen Bits werden zum nächsten Flip-Flop geschoben. Dies bedeutet, dass das Ausgangssignal des ersten Flip-Flops als Eingangssignal des zweiten Flip-Flops dient, das Ausgangssignal des zweiten Flip-Flops als Eingangssignal des dritten Flip-Flops und so weiter.\\
	\pagebreak
	
	Das Fibonacci-\acs{LFSR} zeichnet sich durch das in Gleichung \ref{eq:fiblfsr} dargestellte primitive Generatorpolynom aus. Dies ermöglicht dem Schieberegister die Generierung von Pseudozufallszahlen.
	
	\begin{equation}
		pf(x) = x^8 + x^6 + x^5 + x^4 + 1
		\label{eq:fiblfsr}
	\end{equation} 
	
	
	\subsection{Hardware Timer}
	Der Hardware Timer ist eine Schaltungskomponente, die verwendet wird, um Zeit zu messen oder Zeit basierte Ereignisse zu erzeugen. Er besteht aus einem internen Zähler, der bei jedem Taktimpuls inkrementiert oder dekrementiert wird und so die Grundlage für die Zeiterfassung bildet. Der Hardware Timer wird durch Steuersignale gesteuert, welche das starten, stoppen und zurücksetzen ermöglichen. Diese Steuersignale können entweder von einer externen Steuerung oder durch interne Logik generiert werden.\\
	Damit durch den Hardware Timer eine bestimmte Zeit in Sekunden überbrückt wird, betrachten wir folgende Zusammenhänge. Die Taktfrequenz f gibt an, wie viele Taktzyklen pro Sekunde auftreten. Um eine bestimmte Zeit t in Sekunden zu warten, muss die Anzahl der Takte berechnet werden, die während dieser Zeit vergehen. Dazu wird in Gleichung \ref{eq:clkCount} die Zeit t mit der Taktfrequenz f multipliziert.
	
	\begin{equation}
		\label{eq:clkCount}
		\text{Anzahl der Takte} = t * f
	\end{equation}
	
	Es ist wichtig zu beachten, dass diese Berechnung auf der idealisierten Annahme basiert, dass die Taktfrequenz und der Takt stabil und präzise sind. In der Praxis können jedoch Ungenauigkeiten auftreten, die die Zeitmessung beeinflussen. 
	\pagebreak
	% Nicht Konzept und umsetzung, sondern Register-Transfer-Ebene, Gatter-Ebene, Verdrahtung+Platzierung
	%Implementierung + Validierung
	\section{Schaltkreis Entwurf} %
	\label{sec:icdesign}
	In diesem Kapitel wird die Entstehung des \acs{IC}-Entwurfs unseres Reaktionsspiels erläutert. Durch die Simulation des Designs werden wir die Funktionalität des Reaktionsspiels überprüfen und abschließend ein Layout erstellen, das für die Fertigung des \ac{IC}s im Rahmen des Tiny-Tapeout-Projekts verwendet werden kann.
	\subsection{Das Reaktionsspiel}
	Um den Schaltkreis genau definieren zu können, muss vorab die exakte Funktionsweise des Reaktionsspiels definiert werden. Das Spiel wird ausgelegt für zwei Spieler. Jeder Spieler hat zwei Knöpfe als Eingabemöglichkeit und es gibt einen zusätzlichen Startknopf. Die insgesamt fünf Knöpfe werden als Eingangssignale in den von uns entwickelten \acs{IC} übermittelt. Als Interface für die Kommunikation mit dem Benutzer wird die auf dem Evaluationsboard von Tiny-Tapeout verbaute 7-Segment-Anzeige verwendet.\cite{timoEval} Dadurch ergibt sich das in Abbildung \ref{fig:gameDesign} dargestellte Design für das Reaktionsspiel.
	
	\vspace{1em}
	\begin{minipage}{\linewidth}
		\centering
		\includegraphics[width=1\linewidth]{pics/gameDesign.png}
		\captionof{figure}[gameDesign]{Design des Reaktionsspiels}
		\label{fig:gameDesign}
	\end{minipage}
	\vspace{1em}
	
	Die Leuchtdioden der 7-Segment-Anzeige werden für die Visualisierung drei verschiedener Zustände verwendet, wie in Tabelle \ref{tab:7SegStates} dargestellt.
	
	
	\vspace{1em}
	\begin{table}[H]
		\scriptsize
		\centering
		\begin{tabular}{ | l | m{30em} | }
			\hline
			\textbf{Zustand} & \textbf{Beschreibung} \\
			\hline
			Blinken & Wenn ein Spiel gestartet wird, blinken alle Segmente der Anzeige innerhalb von drei Sekunden drei mal auf\\
			\hline
			Zufälliges Aufleuchten & Nachdem eine pseudo zufällige Wartezeit verstrichen ist, leuchtet entweder das linke (bzw. obere) oder rechte (bzw. untere) Segment auf.\\
			\hline
			Gewinner Anzeigen & Je nachdem, ob ein Spieler zu früh, den richtigen Knopf oder den falschen Knopf drückt wird der Sieger ermittelt. Gewinnt Spieler 1, dann leuchtet die linke (bzw. obere) Hälfte der 7-Segment-Anzeige auf. Gewinnt Spieler 2, dann leuchtet die rechte (bzw. untere) Hälfte der 7-Segment-Anzeige auf.\\
			\hline
		\end{tabular}
		\caption{Erklärung der Zustände der 7-Segment-Anzeige}
		\label{tab:7SegStates}
		\normalsize	
	\end{table}

	Anhand der in Tabelle \ref{tab:7SegStates} definierten Zustände, lässt sich der Spielablauf für unser Reaktionsspiel ableiten. Das Spiel durchläuft die folgenden Schritte:
	
	\begin{enumerate}
		\item Warten bis der Start-Knopf betätigt wird
		\item Sobald das Spiel Startet, blinkt die 7-Segment-Anzeige drei mal auf
		\item Wenn das blinken beendet ist, warte eine (pseudo-)zufällige Zeit
		\item Nach Ablauf der Zufallszeit, leuchtet das linke oder rechte Segment auf
		\item Warte auf Knopfdruck der Spieler
		\item Sieger wird ermittelt und die entsprechenden Segmente in der 7-Segment-Anzeige leuchten auf
	\end{enumerate}
	
	\subsection{Register-Transfer-Ebene} %Hardwarebeschreibungssprache, Zustandsdiagramm und Vhdl code
	Nachdem die grundlegenden Funktionen des \acs{IC}s im vorherigen Kapitel definiert wurden, kann der Entwurf auf Register-Transfer-Ebene beginnen. Der Prozess des Entwurfs durchläuft mehrere Schritte. Zuerst wird der Algorithmus anhand einer einfachen Beschreibungssprache definiert. Danach werden die Zustände des Algorithmus in einem Zustandsübergangsdiagramm modelliert, sodass die Überführung in eine Hardwarebeschreibungssprache (hier \ac{VHDL}) im nächsten Schritt vereinfacht wird. Zuletzt wird das Programm synthetisiert und simuliert. Auf den Entwurf des Algorithmus wird in dieser Stelle nicht tiefer eingegangen, da die Funktionsweise des Schaltkreises in den Schritten des Zustandsübergangsdiagramms und der Überführung in \ac{VHDL} klar wird.
	
	\subsubsection{Zufallsgenerierung}
	Für die Zufallsgenerierung wird, wie im Kapitel \ref{sec:lfsr} eingeführt, ein 8-bit linear rückgekoppeltes Schieberegister verwendet. Als Bereich für die zufällige Wartezeit haben wir eine Zeit zwischen 0,5 und 5 Sekunden definiert. Nach Formel \ref{eq:clkCount} kann abhängig von der Taktfrequenz des Evaluationsboards die Anzahl der Takte ausgerechnet werden, welche mindestens bzw. maximal gewartet werden dürfen um in diesem Bereich zu bleiben. Die Taktfrequenz des Evaluationsboards ist einstellbar.\cite{timoEval} Wir haben für unser Projekt eine Taktfrequenz von 25 Kilohertz festgelegt. Daher ergibt sich für die zufällige Wartezeit von 0,5 Sekunden folgende Taktanzahl: $$cnt_{min} = 25.000 * 0.5 = 12.500$$
	Die maximale Anzahl der Takte lässt sich wie folgt berechnen: $$cnt_{max} = 25.000 * 5 = 125.000$$
	Für den Zähler werden also 17-Bit benötigt, um den Wertebereich bis 125.000 darstellen zu können. Damit mindestens eine halbe Sekunde Wartezeit entsteht, wird der Zähler mit der Bitfolge $0 0011 0001 0000 0000(12.544)$ initialisiert, was in etwa der halben Sekunde entspricht. Für die zufällige Wartezeit werden die drei niedrigsten Bits des \acs{LFSR} für die drei höherwertigsten bits des Zählers verwendet, wie in Abbildung \ref{fig:random} dargestellt ist.
	
	\vspace{1em}
	\begin{minipage}{\linewidth}
		\centering
		\includegraphics[width=1\linewidth]{pics/random.pdf}
		\captionof{figure}[random]{Wertevergabe des Zählers für die zufällige Wartezeit}
		\label{fig:random}
	\end{minipage}
	\vspace{1em}
	
	Somit ergeben sich die in Tabelle \ref{tab:counterStates} dargestellten möglichen Kombinationen für die Wartezeit.
	
	\vspace{1em}
	\begin{table}[H]
		\scriptsize
		\centering
		\begin{tabular}{ | l | l | }
			\hline
			\textbf{Bitfolge} & \textbf{Wartezeit in Sekunden} \\
			\hline
			 0011 0001 00... 0 & 0,50 Sekunden\\
			\hline
			0 0111 0001 00... 0 & 1,16 Sekunden\\
			\hline
			0 1011 0001 00... 0 & 1,81 Sekunden\\
			\hline
			0 1111 0001 00... 0 & 2,47 Sekunden\\
			\hline
			1 0011 0001 00... 0 & 3,12 Sekunden\\
			\hline
			1 0111 0001 00... 0 & 3,78 Sekunden\\
			\hline
			1 1011 0001 00... 0 & 4,43 Sekunden\\
			\hline
			1 1111 0001 00... 0 & 5,09 Sekunden\\
			\hline
		\end{tabular}
		\caption{Alle möglichen Bitfolgen des Zählers für die zufällige Wartezeit}
		\label{tab:counterStates}
		\normalsize	
	\end{table}

	Für die Selektion, ob das linke oder rechte Segment der 7-Segment-Anzeige aufleuchten soll, wird das höchstwertige Bit des \acs{LFSR} extrahiert. Der Wert 0 bedeutet, dass das rechte Segment aufleuchten soll und der Wert 1, dass das linke Segment aufleuchten soll.
	\subsubsection{Zustandsübergrangsdiagramm}
	In Abbildung \ref{fig:stateDiagram} ist das aus dem Algorithmus überführte Zustandsübergangsdiagramm dargestellt. Das Diagramm modelliert die folgenden Zustände:
	
	\begin{itemize}
		\item \textbf{State\textunderscore Reset:} In diesem Startzustand wird auf das drücken des Start-Knopfs gewartet. Sobald dieser gedrückt wurde, wird der Zustand verlassen
		\item \textbf{State\textunderscore blink3Times:} Der Zustand fasst den Ablauf des dreifachen aufblinken der Segmentanzeige zusammen. Ist das Blinken beendet, wird die zufällige Wartezeit initialisiert
		\item \textbf{State\textunderscore waitRndInit:} Setzt den Zähler des Timers auf einen zufälligen Wert, sodass nach Formel \ref{eq:clkCount} eine Zeit zwischen 0.5-5 Sekunden gewartet wird
		\item \textbf{State\textunderscore waitRnd:} Dekrementiert den Zähler bei jedem Clock-Zyklus. Währenddessen wird geprüft, ob ein Spieler einen seiner Knöpfe zu früh betätigt. Falls ja, wird direkt der Gewinner angezeigt. Sonst leuchtet nach Ablauf der Zeit entweder das linke oder rechte Segment auf 
		\item \textbf{State\textunderscore setRightLED:} Das rechte Segment leuchtet und es wird auf Knopfdruck von einem der Spieler gewartet, sodass der Gewinner ermittelt werden kann
		\item \textbf{State\textunderscore setLeftLED:} Das linke Segment leuchtet und es wird auf Knopfdruck von einem der Spieler gewartet, sodass der Gewinner ermittelt werden kann
		\item \textbf{State\textunderscore p1Won:} Spieler 1 hat das Spiel gewonnen, das bedeutet die linke Hälfte der 7-Segment-Anzeige leuchtet auf. Anschließend wird auf ein erneutes drücken des Start-Knopfes gewartet
		\item \textbf{State\textunderscore p2Won:} Spieler 2 hat das Spiel gewonnen, das bedeutet die rechte Hälfte der 7-Segment-Anzeige leuchtet auf. Anschließend wird auf ein erneutes drücken des Start-Knopfes gewartet
	\end{itemize}
	
	\vspace{1em}
	\begin{minipage}{\linewidth}
		\centering
		\includegraphics[width=1\linewidth]{pics/state_transition_diagram_vert.png}
		\captionof{figure}[stateDiagram]{Zustandsübergangsdiagramm des \ac{IC}s}
		\label{fig:stateDiagram}
	\end{minipage}
	\vspace{1em}
	
	Dieser Ablauf stellt exakt die Funktionsweise unseres Algorithmus dar und wurde anschließend von uns in \acs{VHDL}-Code übersetzt. Die Signalbenennung muss, damit die Abgabe bei Tiny-Tapeout stattfinden kann, an das vorgegebene Interface wie folgt angepasst werden.
	\pagebreak
	\begin{minted}{vhdl}
ENTITY ALGORITHMUS IS
  PORT(
    clk : IN STD_LOGIC; -- 25 kHz
    rst_n: IN STD_LOGIC;
    uio_in: IN STD_LOGIC_VECTOR (7 DOWNTO 0);
    uio_oe: out STD_LOGIC_VECTOR (7 DOWNTO 0);
    uo_out : out STD_LOGIC_VECTOR(7 DOWNTO 0);
    ena : in STD_LOGIC
  );
END ALGORITHMUS;
	\end{minted}
%\begin{lstlisting}[label={lst:algo}, language=vhdl ]
%ENTITY ALGORITHMUS IS
%  PORT(
%    clk : IN STD_LOGIC; -- 25 kHz
%    rst_n: IN STD_LOGIC;
%    uio_in: IN STD_LOGIC_VECTOR (7 DOWNTO 0);
%    uio_oe: out STD_LOGIC_VECTOR (7 DOWNTO 0);
%    uo_out : out STD_LOGIC_VECTOR(7 DOWNTO 0);
%    ena : in STD_LOGIC
%  );
%END ALGORITHMUS;
%\end{lstlisting}

	Die Signale $uio_{oe}$, $uio_{in}$ und $uo_{out}$ haben folgende Bedeutung: 
	\begin{itemize}
		\item $uio_{oe}$: Dieses Signal konfiguriert die bidirektionale Input/Output Schnittstelle des Evaluationsboards. (0 = Input, 1 = Output)
		\item $uio_{in}$: Steht für das Input Signal in die 8-Pin-bidirektionale-Input/Output Schnittstelle des Evaluationsboards, diese werden für unsere fünf Spiel-Knöpfe als Inputs verwendet
		\item $uo_{out}$: Steht für das Output Signal der 8-Pin-Output Schnittstelle des Evaluationsboards und ist mit der 7-Segment-Anzeige verbunden
	\end{itemize}
	
	\subsubsection{Simulation}
	Die Simulation unseres Schaltkreises findet in zwei Komponenten statt:
	\begin{enumerate}
		\item \textbf{Testbench}: Um die Korrektheit des Algorithmus zu validieren, wird eine \ac{VHDL}-Testbench geschrieben
		\item \textbf{\ac{FPGA}}: Als weitere Absicherung, wird der Algorithmus so angepasst, dass er auf einem \ac{FPGA} laufend gemacht und das Spiel vorab getestet werden kann
	\end{enumerate}
	
	Nachdem die Testbench erfolgreich elaboriert und simuliert wurde, können wir diese mit dem Tool GTKWave\cite{gtkwave} betrachten. In Abbildung \ref{fig:algoTB} ist der Verlauf der Ein- und Ausgänge unseres \ac{IC}s dargestellt.
	 
	\vspace{1em}
	\begin{minipage}{\linewidth}
		\centering
		\includegraphics[width=1\linewidth]{pics/algoTB.pdf}
		\captionof{figure}[algoTB]{Signalverläufe der Algorithmus Testbench}
		\label{fig:algoTB}
	\end{minipage}
	\vspace{1em}
	
%	Folgende mögliche Abläufe werden von der Testbench simuliert:
%	\begin{enumerate}
%		\item Das linke Segment leuchtet auf und Spieler eins drückt den richtigen Knopf
%		\item Das linke Segment leuchtet auf und Spieler eins drückt den falschen Knopf
%		\item Das rechte Segment leuchtet auf und Spieler zwei drückt den richtigen Knopf
%		\item Das rechte Segment leuchtet auf und Spieler zwei drückt den falschen Knopf
%		\item Spieler eins drückt bevor ein Segment aufleuchtet und verliert
%		\item Spieler zwei drückt bevor ein Segment aufleuchtet und verliert
%	\end{enumerate}

	Für die Simulation mit einem \ac{FPGA} wird das Zybo Zynq-7000 ARM/FPGA SoC Trainer Board \cite{zyboBoard} verwendet. Der Code für den \acs{IC} musste an die Schnittstellen des Boards angepasst werden. Das Reaktionsspiel auf dem \ac{FPGA} wurde im Abschluss-Kolloquium vorgeführt. Leider sind hierbei keine Bildaufnahmen dokumentiert worden.
	\subsection{Gatter-Ebene, Verdrahtung und Platzierung}
	Auf Gatter-Ebene und für die Verdrahtung und Platzierung werden die Aufgaben von Tiny-Tapout abgenommen. Damit dies möglich ist, muss ein Github Projekt angelegt werden, welches sich an einer Vorlage orientiert. In der Projekt-Vorlage wurden Github-Actions angelegt, zur Validierung des Schaltkreises. Wenn alle Tests bestehen, resultiert eine gds-2 Datei\cite{saschaGDS}.
	Da Tiny-Tapeout ausschließlich Verilog als Hardwarebeschreibungssprache akzeptiert, mussten unsere \acs{VHDL}-Dateien mithilfe des Tools yosys\cite{yosys} zu gültigem Verilog Code konvertiert werden. In unserem aktuellen Stand, wurde der Verilog Algorithmus von den Github-Actions akzeptiert, wie in Abbildung \ref{fig:ttGit} zu sehen ist. Vor der Einreichung bei Tiny-Tapeout, muss der konvertierte Code für den Algorithmus erneut auf Richtigkeit überprüft werden.
	
	\vspace{1em}
	\begin{minipage}{\linewidth}
		\centering
		\includegraphics[width=0.85\linewidth]{pics/ttGit.png}
		\captionof{figure}[ttGit]{Tiny-Tapeout04 Github Repository}
		\label{fig:ttGit}
	\end{minipage}
	\vspace{1em}
	
	Darüber hinaus ermöglicht GitHub den Zugriff auf eine Statistik, die zusammenfasst, wie häufig bestimmte Standardzellen in unserem Schaltkreis vorkommen. Wie aus Abbildung \ref{fig:cellUsage} entnommen werden kann, wird für unsere Schaltung 228 Zellen benötigt. Für den Schaltkreis werden Combo Logic, Flip Flops, Buffer, Or, And, Nand, Inverter und Multiplexer verwendet. Interessant wäre eine Analyse der Misc(dt. "Verschiedenes") Zellen, da diese Latches oder ähnliches beinhalten könnten, welche es im Hardwaredesign zu vermeiden gilt.
	
	\vspace{1em}
	\begin{minipage}{\linewidth}
		\centering
		\includegraphics[width=0.85\linewidth]{pics/cellUsage.png}
		\captionof{figure}[ttGit]{Zellübersicht nach Synthese des Algorithmus}
		\label{fig:cellUsage}
	\end{minipage}
	\vspace{1em}
	
	\pagebreak
	\section{Zusammenfassung und Ausblick}
	\label{sec:eval}
	Das \ac{IC}-Design für das Reaktionsspiel wurde erfolgreich implementiert und auf einem \ac{FPGA} getestet. Das Spiel funktionierte wie erwartet, und die Spieler konnten ihre Reaktionszeit messen, indem sie den richtigen Knopf zur richtigen Zeit drückten. Die LEDs zeigten die Spielzustände korrekt an, einschließlich des Blinkens, der zufälligen aufleuchtenden LED und der Anzeige des Gewinners. Beim Testen mit einer VHDL Testbench wurden verschiedene Szenarien durchgespielt, um sicherzustellen, dass das Spiel korrekt reagiert und die gewünschten Ergebnisse liefert. Das \ac{IC}-Design erwies sich als robust und zuverlässig in Bezug auf die Spiellogik.
	
	Das \ac{IC}-Design erfüllt alle definierten Anforderungen. Es verwendet die vorgegebenen Eingänge und Ausgänge des Tiny-Tapeout-Evaluationsboards und beschränkt sich auf maximal 500 Logikgatter. Der Entwurf soll im Rahmen des nächsten Rollouts eingereicht werden, sodass der \acs{IC} entstehen kann. Allerdings muss der von \ac{VHDL} zu Verilog konvertierte Algorithmus zuvor noch getestet werden.
	
	Der Entwurf des \ac{IC}s hat zu wertvoller Erfahrung im Bereich der Hardwareentwicklung geführt. Es konnten Kenntnisse und Fähigkeiten im \acs{IC}-Design erlangt werden. Die Berücksichtigung verschiedener Aspekte, wie die Auswahl geeigneter Logikgatter und das Routing von Signalen hat geholfen, wertvolle Erkenntnisse zu erlangen. 

	
	\pagebreak
	% ----------------------------------------------------------------------------------------------------------
	% Abkürzungsverzeichnis
	% ----------------------------------------------------------------------------------------------------------
	\section{Abkürzungsverzeichnis}
	\rhead{Abkürzungsverzeichnis}
	\vspace{1em}
	\begin{acronym}[KDE]
		\acro{IC}[IC]{integrierter Schaltkreis}
		\acrodefplural{IC}[IC]{integrierten Schaltkreises}
		\acro{LFSR}[LFSR]{linear rückgekoppeltes Schieberegister}
		\acro{VHDL}[VHDL]{\textbf{V}ery High Speed Integrated Circuits \textbf{H}ardware \textbf{D}escription \textbf{L}anguage}
		\acro{FPGA}[FPGA]{Field Programmable Gate Array}
	\end{acronym}
	
		% ----------------------------------------------------------------------------------------------------------
	% Literatur
	% ----------------------------------------------------------------------------------------------------------
	%	\renewcommand\refname{Referenzen}
	%	\lhead{}
	%	\bibliographystyle{ieeetr}
	%	\bibliography{referenzen}
	%	\pagebreak
	
	\section{Literaturverzeichnis}
	\printbibliography
%	\rhead{Literaturverzeichnis}
%	\bibliographystyle{alpha}
%%	\bibliographystyle{ieeetr}
%	\renewcommand\refname{}
%	\bibliography{literatur}
	\pagebreak
	
	
	
\end{document}
